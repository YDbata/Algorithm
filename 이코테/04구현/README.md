# 구현

## 피지컬로 승부하기
'구현'이란 머리속에 있는 알고리즘을 소스코드로 바꾸는 과정이다.

일반 알고리즘 책에서는 구현은 모든 코딩 테스트의 문제 유형을<br>
포함하는 개념이기 때문에 별도 파트가 없다.

흔히 문제해결 분야에서 구현 유형의 문제는<br>
'풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제'를 의미한다.

### 실제 구현하기 어려운 문제 예시

- 알고리즘은 간단한데 고드가 지나칠만큼 길어지는 문제
- 특정 소수점 자리까지 출력해야하는 문제
- 문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에 넣어야 하는(**문자열 파싱**) 문제

위의 구현 문제들을 만나면 당황할 수 있다. 머리에는 있는데 코드로 옮겨지지 않기 때문이다.<br>
또한 문법을 모르거나 라이브러리 사용 경험이 부족하면 구현 유형의 문제를 풀때 불리하다.

이 책은 '완전 탐색', '시뮬레이션' 유형들을 모두 **'구현'**으로 묶었다.<br>

※ 완전탐색 : 모든 경우의 수를 주저 없이 다 계산 하는 해결 방법<br>
※ 시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행하는 방법<br>

이제 코딩테스트를 준비함에 있어 어떤환경에서 문제를 푸는지를 알고 그 환경에 맞게 코딩하는 일이 중요하므로,<br>
먼저 코딩 테스트의 채점 시스템의 제약에 대해 설명한 후 문제를 다룬다.

## 구현시 고려해야 할 메모리 제약 사항

### C/C++에서 변수의 표현 범위

전통적으로 프로그래밍에서 정수형(integer)을 표현할 때는 int자료형(4byte)을 주로 사용한다.<br>
int 자료형의 표현 범위는 -2,147,483,648 ~ 2,147,483,648이다.<br>
이는 이 범위를 넘어서는 숫자는 처리할 수 없다는 의미이다.

이제 이보다 큰 유형은 다른 자료형을 이용하게 되는데 크기가 8byte인 long long이 대표적이다.<br>
하지만 이 또한 9,223,372,036,854,775,807의 범위를 가지며 이보다 큰 수를 구현 할때는 흔히<br>
BigInteger 클래스를 구현하거나 이용한다.<br>
자바의 경우 BigInterger 표준 라이브러리가 있지만 C++의 경우 없다.

**위 범위 정리**

|정수형 종류|자료형의 크기(byte)|자료형의 범위|
|:---|:---|:---|
|**int**|4|-2,147,483,648 ~ 2,147,483,648|
|**long long**|8|-9,223,372,036,854,775,807 ~ 9,223,372,036,854,775,807|
|**BigInteger**|가변적|제한 없음|

위의 JAVA, C/C++과 다르게 Python은 프로그래머가 자료형을 지정할 필요가 없으며<br>
매우 큰 수의 연산을 기본으로 지원한다.<br>
때문에 Python은 자료형에서 자유롭지만 실수형은 다른 언어와 같이 유효숫자에 따라<br>
연산 결과가 다를수 있다는 점을 기억해야한다.

#### Python에서 리스트 크기

파이썬에서 여러 개의 변수를 사용할 때는 리스트를 사용하는데 이 때 코딩테스트의 메모리 제한을 고려해야한다.<br>
코테에서는 대개 128~512(MB)로 메모리를 제한한다. 이 때문에 알고리즘 문제 중에 수백만 이상의 데이터를 다룰 때<br>
메모리 제한을 염두해두고 풀어야한다.

**int 자료형 데이터의 개수에 따른 메모리 사용량**

|데이터의 개수<br>(리스트길이)|메모리 사용량|
|:---|:---|
|**1,000**|약 4KB|
|**1,000,000**|약 4MB|
|**10,000,000**|약 40Mb|

대개 Python으로 문제를 풀다가 1000만개 정도 크기의 리스트가 만들어 졌다면 메모리 용량 제한에 걸리수 있다.

## 채점 환경

채점 환경은 출제 기관, 문제 마다 조금씩 다르다.<br>
대개 코딩테스트 환경에서는 채점 시스템의 시간 제한 및 메모리 제한 정보가 적혀 있다.

파이썬 기준으로 1초에 2000만번 정도 연산한다고 가정하면 100만개의 데이터를 다루는데<br>
O(NlogN)이내의 알고리즘을 사용해야한다.

## 구현 문제에 접근하는 방법

구현 문제는 문제의 길이가 긴것에 비해 난이도가 높지 않다.<br>
구현 문제는 C/C++, JAVA로 작성할 때 더 어려워보인다.

## 예제 4-1 상하좌우

```python
N = int(input())
h = {'D': (1, 0), 'U': (-1, 0), 'L': (0, -1), 'R': (0, 1)}

move_l = input().split()
idx = [1, 1]


def is_save(n):
    return 1 if 0 < n < (N + 1) else 0


for m in move_l:
    tmp_x = idx[0] + h[m][0]
    tmp_y = idx[1] + h[m][1]
    if is_save(tmp_x) and is_save(tmp_y):
        idx = [tmp_x, tmp_y]

print(*idx, sep=" ")
```

## 예제 4-2 시각

```python
N = int(input())

re = (N + 1)*6*10*6*10 - N*5*9*5*9

print(re)
```

## 실전 문제

### 왕실의 나이트

```python
dir = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (-1, 2), (1, -2), (-1, -2)]

loc = input()

loc_x = ord(loc[0]) - ord('a') + 1
loc_y = int(loc[1])


def is_save(n):
    return 1 if 0 < n < 9 else 0


re = 0
for d in dir:
    if is_save(loc_x + d[0]) and is_save(loc_y + d[1]):
        re += 1

print(re)
```

### 게임개발

```python
N, M = map(int, input().split())

A, B, D = map(int, input().split())

board = []

for n in range(N):
    board.append(list(map(int, input().split())))

direct = [(-1, 0), (0, 1), (1, 0), (0, -1)]


def check(a, b):
    for d in direct:
        if board[a + d[0]][b + d[1]] == 0:
            return 1

    return 0


re = 1
while check(A, B):
    D = (4 + (D - 1)) % 4
    tmp_dir = direct[D]
    if board[A + tmp_dir[0]][B + tmp_dir[1]] == 0:
        board[A][B] = 2
        A += tmp_dir[0]
        B += tmp_dir[1]
        re += 1


print(re) 
```



