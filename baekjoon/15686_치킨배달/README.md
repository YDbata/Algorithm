#15686 치킨배달

https://www.acmicpc.net/problem/15686

## 문제 이해

### 규칙

```
0 2 0 1 0
1 0 1 0 0
0 0 0 0 0
0 0 0 1 1
0 0 0 1 2
```

이 도시에 사는 사람들은 치킨을 매우 좋아한다. 따라서, 사람들은 "치킨 거리"라는 말을 주로 사용한다.<br>
치킨 거리는 집과 가장 가까운 치킨집 사이의 거리이다.<br>
즉, 치킨 거리는 집을 기준으로 정해지며, 각각의 집은 치킨 거리를 가지고 있다.<br>
**도시의 치킨 거리는 모든 집의 치킨 거리의 합**이다.

**임의의 두 칸 `(r1, c1)과 (r2, c2)`** 사이의 거리는 `|r1-r2| + |c1-c2|`로 구한다.

**0**은 **빈 칸**, **1**은 **집**, **2**는 **치킨집**이다.

(2, 1)에 있는 **집**과 (1, 2)에 있는 **치킨집**과의 **거리는 |2-1| + |1-2| = 2**,<br>
(5, 5)에 있는 치킨집과의 거리는 |2-5| + |1-5| = 7이다. 따라서, (2, 1)에 있는 집의 치킨 거리는 2이다.

(5, 4)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는 |5-1| + |4-2| = 6,<br>
(5, 5)에 있는 치킨집과의 거리는 |5-5| + |4-5| = 1이다. 따라서, (5, 4)에 있는 집의 치킨 거리는 1이다.

이 도시에 있는 치킨집은 모두 같은 프랜차이즈이다.<br>
프렌차이즈 본사에서는 수익을 증가시키기 위해 **일부 치킨집을 폐업**시키려고 한다.<br>
오랜 연구 끝에 이 도시에서 가장 수익을 많이 낼 수 있는  치킨집의 개수는 **최대 M개**라는 사실을 알아내었다.

도시에 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업시켜야 한다.<br>
어떻게 고르면, **도시의 치킨 거리가 가장 작게 될지** 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 `N(2 ≤ N ≤ 50)`과 `M(1 ≤ M ≤ 13)`이 주어진다.

둘째 줄부터 **N개의 줄에는 도시의 정보**가 주어진다.

**도시의 정보**는 **0, 1, 2**로 이루어져 있고, **0은 빈 칸, 1은 집, 2는 치킨집**을 의미한다.<br>
**집의 개수는 2N개를 넘지 않으며, 적어도 1개**는 존재한다.<br>
**치킨집의 개수는 M보다 크거나 같고, 13보다 작거나 같다.**

### 출력

첫째 줄에 **폐업시키지 않을 치킨집을 최대 M개**를 골랐을 때, 도시의 **치킨 거리의 최솟값**을 출력한다.

## Input 예시
### 2번
5 2<br>
0 2 0 1 0<br>
1 0 1 0 0<br>
0 0 0 0 0<br>
2 0 0 1 1<br>
2 2 0 1 2<br>

정답: 10

### 4번
5 1<br>
1 2 0 2 1<br>
1 2 0 2 1<br>
1 2 0 2 1<br>
1 2 0 2 1<br>
1 2 0 2 1<br>

정답: 32

## 풀이

python라이브러리 itertools의 combinations이 있지만 직접 구현해 보았다.
(속도차이는 80ms정도 난다...)
```python
def combi(ml, m, re, b, start):
    if m == 0:
        tmp = 0
        for i in range(nl):
            tmp += distance[i][min(b, key=lambda x: distance[i][x])]

        if tmp < re:
            re = tmp
    else:
        for i in range(start, ml):
            b.append(i)
            re = combi(ml, m - 1, re, b, i + 1)
            b.pop()

    return re
```

#### 이번 combination의 특이사항
python에서 min을 사용할 때 `key=lambda x: distance[i][x]`를 사용하여 뽑힌 컬럼 중에서도 거리가 작은 열이 반환되게 하였다.<br>
이를 사용하면 컬럼을 뽑을 때마다 비교해주는 대신 컬럼 index를 모아놓고 비교하는 것이 가능해진다.

main이다. input을 받아서 집과 치킨집 리스트를 만들고 2차원의 거리 리스트에 각각의 거리를 미리 저장해둔다.<br>
combi에서 min값을 계산할 때 이용된다.
```python
if __name__=="__main__":
    n, m = map(int, input().split())


    n_list = []
    m_list = []
    for r in range(n):
        tmp = list(map(int, input().split()))
        for c in range(n):
            if tmp[c] == 1:
                n_list.append((r, c))
            elif tmp[c] == 2:
                m_list.append((r, c))

    ml = len(m_list)
    nl = len(n_list)
    distance = [[0 for _ in range(ml)] for _ in range(nl)]
    for r in range(nl):
        for c in range(ml):
            distance[r][c] = abs(n_list[r][0] - m_list[c][0]) + abs(n_list[r][1] - m_list[c][1])

    print(combi(ml, m, n*nl, [], 0))
```